<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>Stranger Craft - Modo Arquiteto</title>
    <link rel="stylesheet" href="./styles/global.css" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
          "@dimforge/rapier3d-compat": "https://cdn.jsdelivr.net/npm/@dimforge/rapier3d-compat@0.11.2/+esm"
        }
      }
    </script>
  </head>
  <body>
    <div id="loading">Gerando Mundo...</div>
    <div class="damage-overlay" id="damage-overlay"></div>
    <div id="dimension-label">MUNDO INVERTIDO</div>
    <div id="city-radar">Procurando sinal de civilização...</div>
    <div id="ui"></div>
    <div id="dialog-box"></div>

    <div id="hud-stats">
      <div class="stat-bar" id="oxygen-bar" title="Oxigênio">
        <div class="stat-fill" id="oxygen-fill"></div>
      </div>
      <div class="stat-bar" id="health-bar" title="Vida">
        <div class="stat-fill" id="health-fill"></div>
      </div>
      <div class="stat-bar" id="stamina-bar" title="Estamina">
        <div class="stat-fill" id="stamina-fill"></div>
      </div>
    </div>

    <div id="instructions">
      <b>Sobrevivência:</b><br />
      WASD - Mover (Shift p/ Correr)<br />
      ESPAÇO - Pular<br />
      Clique Esq - Ação (Quebrar/Construir)<br />
      Clique Dir - Colocar Bloco<br />
      <b>G</b> - Alternar Modo Construção<br />
      <b>F</b> - Interagir (NPC)<br />
      1-9 - Escolher
    </div>
    <div id="block-info">Modo: Blocos</div>
    <div id="mode-label">Pressione G para Projetos</div>
    <div id="time-display">12:00</div>
    <div id="hotbar"></div>

    <script type="module">
      import * as THREE from "three";
      import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";
      import RAPIER from "@dimforge/rapier3d-compat";

      // Importar módulos
      import {
        randomSeed,
        getFaceUVs,
        createTextureAtlas,
      } from "./lib/utils.js";
      import {
        createNoiseFunction,
        getLayeredNoise,
        getCaveDensity,
      } from "./lib/noise.js";
      import {
        getTerrainHeight,
        getCityInfo,
        getBlock,
        isSolid,
        setBlock,
        markChunkDirty,
        checkBlockPhysics,

        generateChunk,
        generateChunkAsync,
      } from "./lib/terrain.js";
      import { Entity, Zombie, MutantZombie, Builder } from "./lib/entities.js";
      import { Skeleton, Loot, Projectile } from "./lib/new-entities.js";
      import { SaveLoadSystem } from "./lib/save-load.js";
      import { initPhysics } from "./lib/physics.js";
      // NOVO: Imports de Debug e Validação
      import { Logger } from "./lib/debug.js";
      import { validateConfig, validatePosition, validateInitialization } from "./lib/validation.js";
      import { calculateAO, buildChunk } from "./lib/rendering.js";
      import {
        updateHotbar,
        updatePlayerUI,
        updateEnvironment,
      } from "./lib/ui.js";
      import { createBlueprints } from "./lib/blueprints.js";

      // Carregar configurações com validação
      Logger.info('Carregando configurações...');
      let blocksConfig, biomesConfig, gameConfig, blueprintsConfig, inlineData;
      
      try {
        [blocksConfig, biomesConfig, gameConfig, blueprintsConfig, inlineData] =
          await Promise.all([
            fetch("./config/blocks.json").then((r) => r.json()),
            fetch("./config/biomes.json").then((r) => r.json()),
            fetch("./config/game.json").then((r) => r.json()),
            fetch("./config/blueprints.json").then((r) => r.json()),
            fetch("./config/inline-data.json").then((r) => r.json()),
          ]);
          
        validateConfig(blocksConfig, 'blocks');
        validateConfig(biomesConfig, 'biomes');
        Logger.info('Configurações carregadas com sucesso');
      } catch (err) {
        Logger.error('Falha crítica ao carregar configurações', err);
        document.getElementById("loading").innerText = "Erro Fatal: Falha no carregamento";
        throw new Error('Configuration loading failed');
      }

      // Constantes do jogo
      const BLOCKS = blocksConfig.BLOCKS;
      const BLOCK_PROPS = blocksConfig.BLOCK_PROPS;
      const UV_MAP = blocksConfig.UV_MAP;
      const BIOMES = biomesConfig;
      const { world, player, physics } = gameConfig;
      const {
        CHUNK_SIZE,
        CHUNK_HEIGHT,
        RENDER_DISTANCE,
        PHYSICS_DISTANCE,
        SPAWN_DISTANCE,
        DESPAWN_DISTANCE,
        WATER_LEVEL,
      } = world;
      const { PLAYER_HALF_HEIGHT, PLAYER_RADIUS } = player;

      // Seed e RNG
      const SEED = Math.floor(Math.random() * 2147483647);
      const rng = randomSeed(SEED);
      const noise = createNoiseFunction(rng);

      // Blueprints
      const BLUEPRINTS = createBlueprints(BLOCKS);

      // NOVO: Sistema de Save/Load
      const saveLoadSystem = new SaveLoadSystem();
      
      // UI Text (de inline-data.json)
      const UI_TEXT = inlineData;

      // Estados
      const gameState = {
        time: 0.5,
        dayDuration: 600,
        dimension: "NORMAL",
        lightningTimer: 0,
        spawnTimer: 0,
      };
      const playerStats = {
        health: 100,
        maxHealth: 100,
        oxygen: 100,
        maxOxygen: 100,
        stamina: 100,
        maxStamina: 100,
        lastVelocityY: 0,
      };
      let interactionMode = "BLOCK";
      let selectedBlock = BLOCKS.GRASS;
      let selectedBlueprintIndex = 0;

      // Three.js Setup
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      scene.fog = new THREE.Fog(0x87ceeb, 20, RENDER_DISTANCE * CHUNK_SIZE - 5);

      const camera = new THREE.PerspectiveCamera(
        70,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer({ antialias: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = false;
      document.body.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
      scene.add(ambientLight);

      const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
      sunLight.position.set(50, 100, 50);
      scene.add(sunLight);

      // Sistema de partículas otimizado
      import {
        InstancedParticleSystem,
        createLegacyParticles,
        updateLegacyParticles,
      } from "./lib/particles.js";
      const particleSystem = new InstancedParticleSystem(scene, 10000);

      const controls = new PointerLockControls(camera, document.body);

      // Texturas
      const textureAtlas = await createTextureAtlas();
      const materialOpaque = new THREE.MeshBasicMaterial({
        map: textureAtlas,
        vertexColors: true,
        side: THREE.DoubleSide,
      });
      const materialTrans = new THREE.MeshBasicMaterial({
        map: textureAtlas,
        transparent: true,
        opacity: 0.75, // Água mais transparente
        alphaTest: 0.1,
        side: THREE.DoubleSide,
        vertexColors: true,
        color: 0x2196F3, // Azul oceano
      });

      // Wrapper para getFaceUVs
      const getFaceUVsWrapper = (type, faceName) =>
        getFaceUVs(type, faceName, BLOCKS, UV_MAP);

      // Mundo e Física
      let chunks = {};
      let physicsWorld, playerBody, playerCollider;
      const entities = [];

      // Funções auxiliares com closures (integradas com Save/Load)
      const getBlockWrapper = (x, y, z) => {
        // NOVO: Verificar saveLoadSystem primeiro
        const savedChange = saveLoadSystem.getChange(x, y, z);
        if (savedChange !== null) return savedChange;
        
        return getBlock(x, y, z, chunks, CHUNK_SIZE, CHUNK_HEIGHT, BLOCKS);
      };
      
      const isSolidWrapper = (x, y, z) =>
        isSolid(x, y, z, chunks, CHUNK_SIZE, CHUNK_HEIGHT, BLOCKS);
        
      const setBlockWrapper = (x, y, z, type) => {
        // NOVO: Rastrear mudança no saveLoadSystem
        saveLoadSystem.trackChange(x, y, z, type);
        
        return setBlock(
          x,
          y,
          z,
          type,
          chunks,
          CHUNK_SIZE,
          CHUNK_HEIGHT,
          markChunkDirtyWrapper,
          checkBlockPhysicsWrapper
        );
      };
      const markChunkDirtyWrapper = (cx, cz) => markChunkDirty(cx, cz, chunks);
      const checkBlockPhysicsWrapper = (x, y, z) =>
        checkBlockPhysics(
          x,
          y,
          z,
          getBlockWrapper,
          setBlockWrapper,
          CHUNK_HEIGHT,
          BLOCKS,
          BLOCK_PROPS
        );
      const getTerrainHeightWrapper = (gx, gz) =>
        getTerrainHeight(gx, gz, noise, BIOMES, gameState);
      const getCityInfoWrapper = (cx, cz) => getCityInfo(cx, cz, CHUNK_SIZE);
      const generateChunkWrapper = async (cx, cz) =>
        await generateChunkAsync(
          cx,
          cz,
          CHUNK_SIZE,
          CHUNK_HEIGHT,
          WATER_LEVEL,
          BLOCKS,
          BIOMES,
          gameState,
          SEED
        );

      // Inicialização
      async function init() {
        Logger.info('Iniciando jogo...');
        
        try {
          const physicsData = await initPhysics(
            PLAYER_HALF_HEIGHT,
            PLAYER_RADIUS,
            getTerrainHeightWrapper
          );
          
          if (!physicsData || !physicsData.physicsWorld) {
            throw new Error('Falha ao inicializar física');
          }
          
          physicsWorld = physicsData.physicsWorld;
          playerBody = physicsData.playerBody;
          playerCollider = physicsData.playerCollider;
          Logger.info('Física inicializada');

          const h = getTerrainHeightWrapper(5, 5).height;
          entities.push(
            new Builder(
              15,
              h + 10,
              15,
              scene,
              physicsWorld,
              BLOCKS,
              getTerrainHeightWrapper,
              setBlockWrapper,
              getCityInfoWrapper,
              CHUNK_SIZE,
              DESPAWN_DISTANCE
            )
          );

          // NOVO: Gerar chunks iniciais ANTES de liberar o jogo
          Logger.info('Gerando chunks iniciais...');
          document.getElementById("loading").innerText = "Construindo terreno...";
          await generateInitialChunks(scene, physicsWorld);
          Logger.info('Terreno inicial pronto');

          // Validar posição do spawn
          const pPos = playerBody.translation();
          const groundH = getTerrainHeightWrapper(pPos.x, pPos.z).height;
          if (pPos.y < groundH + 2) {
             Logger.warn('Ajustando altura do spawn para evitar queda');
             playerBody.setTranslation({x: pPos.x, y: groundH + 5, z: pPos.z}, true);
          }

          // Validação final
          const val = validateInitialization({physicsWorld, playerBody, chunks, entities});
          if (!val.valid) throw new Error(val.errors.join(', '));

          document.getElementById("loading").style.display = "none";
          document.body.addEventListener("click", () => {
            if (!controls.isLocked) controls.lock();
          });

          const hotbarEl = document.getElementById("hotbar");
          updateHotbar(
            interactionMode,
            selectedBlock,
            selectedBlueprintIndex,
            BLOCKS,
            BLOCK_PROPS,
            BLUEPRINTS,
            gameState,
            hotbarEl
          );

          animate();
        } catch (err) {
          Logger.error('Erro fatal na inicialização', err);
          document.getElementById("loading").innerHTML = `
            <div style="color: #ff5555; text-align: center; margin-top: 20%;">
              <h2>Falha na Inicialização</h2>
              <p>${err.message}</p>
              <br>
              <button onclick="location.reload()" style="padding: 10px 20px; font-size: 16px; cursor: pointer;">Tentar Novamente</button>
            </div>
          `;
        }
      }

      // Função para garantir área segura inicial
      async function generateInitialChunks(scene, physicsWorld) {
        const pos = playerBody.translation();
        const px = Math.floor(pos.x / CHUNK_SIZE);
        const pz = Math.floor(pos.z / CHUNK_SIZE);
        const radius = 1; // 3x3 chunks ao redor
        const promises = [];

        for(let x = -radius; x <= radius; x++) {
          for(let z = -radius; z <= radius; z++) {
            const cx = px + x, cz = pz + z;
            const key = `${cx},${cz}`;
            if(!chunks[key]) {
              chunks[key] = { generating: true, dirty: false };
              promises.push(
                generateChunkWrapper(cx, cz).then(data => {
                  chunks[key] = { data: data, dirty: true };
                }).catch(e => {
                  Logger.error(`Falha chunk ${key}`, e);
                  delete chunks[key];
                })
              );
            }
          }
        }
        
        await Promise.all(promises);
        
        // Forçar construção da física IMEDIATAMENTE
        for(let x = -radius; x <= radius; x++) {
          for(let z = -radius; z <= radius; z++) {
             const cx = px + x, cz = pz + z;
             const key = `${cx},${cz}`;
             if(chunks[key] && chunks[key].dirty) {
               buildChunk(cx, cz, chunks, scene, physicsWorld, playerBody, CHUNK_SIZE, CHUNK_HEIGHT, PHYSICS_DISTANCE, BLOCKS, BLOCK_PROPS, materialOpaque, materialTrans, getFaceUVsWrapper, isSolidWrapper, getBlockWrapper);
             }
          }
        }
      }

      // Função de frustum culling otimizada
      function isChunkInFrustum(cx, cz, camera, pos) {
        const chunkWorldX = cx * CHUNK_SIZE;
        const chunkWorldZ = cz * CHUNK_SIZE;

        // Centro do chunk
        const chunkCenter = new THREE.Vector3(
          chunkWorldX + CHUNK_SIZE / 2,
          pos.y, // Usar altura do jogador como referência
          chunkWorldZ + CHUNK_SIZE / 2
        );

        // Vetor da câmera para o chunk
        const toChunk = chunkCenter.clone().sub(camera.position);
        const distance = toChunk.length();

        // Direção da câmera (frente)
        const cameraDirection = new THREE.Vector3(0, 0, -1);
        cameraDirection.applyEuler(camera.rotation);

        // Ângulo entre direção da câmera e vetor para o chunk
        const angle = toChunk.angleTo(cameraDirection);

        // Campo de visão horizontal aproximado (70 graus em radianos)
        const fov = (70 * Math.PI) / 180;

        // Distância máxima baseada no ângulo
        const maxDistance = Math.cos(angle) * (RENDER_DISTANCE * CHUNK_SIZE);

        // Para terrenos planos, reduzir carregamento atrás da câmera
        const isBehind = angle > Math.PI / 2;
        const heightFactor = Math.max(0.3, Math.min(1.0, (pos.y + 10) / 50)); // Alturas baixas = menos carregamento atrás

        if (isBehind && heightFactor < 0.7) {
          // Só carregar atrás se estiver muito próximo ou em altura alta
          return distance < CHUNK_SIZE * 2;
        }

        // Verificar se está dentro do cone de visão
        return distance <= maxDistance && angle <= fov / 2;
      }

      // Atualização do mundo
      async function updateWorld() {
        if (!playerBody) return;
        try {
          const pos = playerBody.translation();
          const px = Math.floor(pos.x / CHUNK_SIZE);
          const pz = Math.floor(pos.z / CHUNK_SIZE);

          // Radar de Cidade
          const city = getCityInfoWrapper(px, pz);
          const radar = document.getElementById("city-radar");
          if (city.exists) {
            const dist = Math.round(
              Math.sqrt(
                Math.pow(pos.x - city.worldX, 2) +
                  Math.pow(pos.z - city.worldZ, 2)
              )
            );
            radar.innerText = `SINAL DE CIVILIZAÇÃO: ${dist}m`;
            radar.style.color = dist < 200 ? "#00ff00" : "#ffff00";
          } else {
            radar.innerText = "NENHUM SINAL POR PERTO...";
            radar.style.color = "#ff0000";
          }

          // Geração assíncrona de chunks com frustum culling
          const generationPromises = [];
          for (let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {
            for (let z = -RENDER_DISTANCE; z <= RENDER_DISTANCE; z++) {
              const cx = px + x;
              const cz = pz + z;
              const key = `${cx},${cz}`;

              // Otimização: só gerar chunks visíveis ou próximos
              if (
                !chunks[key] &&
                (Math.abs(x) <= 2 ||
                  Math.abs(z) <= 2 ||
                  isChunkInFrustum(cx, cz, camera, pos))
              ) {
                chunks[key] = { generating: true, dirty: false };
                generationPromises.push(
                  generateChunkWrapper(cx, cz)
                    .then((data) => {
                      chunks[key] = { data: data, dirty: true };
                      markChunkDirtyWrapper(cx - 1, cz);
                      markChunkDirtyWrapper(cx + 1, cz);
                      markChunkDirtyWrapper(cx, cz - 1);
                      markChunkDirtyWrapper(cx, cz + 1);
                    })
                    .catch((error) => {
                      // Silencioso em caso de erro individual
                      delete chunks[key];
                    })
                );
              }
            }
          }

          // Aguardar conclusão de algumas gerações (não todas para não bloquear)
          if (generationPromises.length > 0) {
            await Promise.race(generationPromises);
          }

          let built = 0;
          const chunksToBuild = [];
          for (const key in chunks) {
            if (chunks[key].dirty && !chunks[key].generating) {
              const [cx, cz] = key.split(",").map(Number);
              const dist = Math.abs(cx - px) + Math.abs(cz - pz);
              if (dist <= RENDER_DISTANCE * 2)
                chunksToBuild.push({ key, cx, cz, dist });
            }
          }
          chunksToBuild.sort((a, b) => a.dist - b.dist);
          for (const c of chunksToBuild) {
            buildChunk(
              c.cx,
              c.cz,
              chunks,
              scene,
              physicsWorld,
              playerBody,
              CHUNK_SIZE,
              CHUNK_HEIGHT,
              PHYSICS_DISTANCE,
              BLOCKS,
              BLOCK_PROPS,
              materialOpaque,
              materialTrans,
              getFaceUVsWrapper,
              isSolidWrapper,
              getBlockWrapper
            );
            built++;
            if (built >= 4) break;
          }

          // Limpeza periódica (Despawn)
          const DESPAWN_DIST_LIMIT = RENDER_DISTANCE + 4;
          for (const key in chunks) {
            const chunk = chunks[key];
            const [cx, cz] = key.split(",").map(Number);
            const distance = Math.abs(cx - px) + Math.abs(cz - pz);

            if (chunk.rigidBody) {
              if (distance > PHYSICS_DISTANCE) {
                physicsWorld.removeCollider(chunk.collider, false);
                physicsWorld.removeRigidBody(chunk.rigidBody);
                chunk.collider = null;
                chunk.rigidBody = null;
              }
            } else if (
              !chunk.rigidBody &&
              chunk.mesh &&
              chunk.mesh.geometry.attributes.position.count > 0
            ) {
              if (distance <= PHYSICS_DISTANCE) chunk.dirty = true;
            }

            if (distance > DESPAWN_DIST_LIMIT) {
              import("./lib/rendering.js").then((module) => {
                const { disposeChunk } = module;
                disposeChunk(chunk, scene, physicsWorld);
                delete chunks[key];
              });
            }
          }
        } catch (err) {
           Logger.error('Erro no updateWorld', err);
        }
      }

      // Controles
      const clock = new THREE.Clock();
      const keys = {};
      document.addEventListener("keydown", (e) => {
        keys[e.code] = true;
        if (e.code === "KeyF") {
          const pos = playerBody.translation();
          entities.forEach((ent) => {
            if (ent instanceof Builder) {
              const ePos = ent.rigidBody.translation();
              const dist = Math.sqrt(
                Math.pow(pos.x - ePos.x, 2) + Math.pow(pos.z - ePos.z, 2)
              );
              if (dist < 5) ent.interact();
            }
          });
        }
        if (e.code === "KeyG") {
          interactionMode = interactionMode === "BLOCK" ? "BLUEPRINT" : "BLOCK";
          const hotbarEl = document.getElementById("hotbar");
          updateHotbar(
            interactionMode,
            selectedBlock,
            selectedBlueprintIndex,
            BLOCKS,
            BLOCK_PROPS,
            BLUEPRINTS,
            gameState,
            hotbarEl
          );
          const label = document.getElementById("block-info");
          const modeLabel = document.getElementById("mode-label");
          if (interactionMode === "BLUEPRINT") {
            label.innerText = "Modo: Projetos (Arquiteto)";
            modeLabel.innerText = "Clique esquerdo para construir";
          } else {
            label.innerText = "Modo: Blocos";
            modeLabel.innerText = "Pressione G para Projetos";
            selectBox.visible = false;
            previewMesh.visible = false;
          }
        }
      });
      document.addEventListener("keyup", (e) => (keys[e.code] = false));

      // Spawning
      function updateSpawning(dt) {
        gameState.spawnTimer += dt;
        if (gameState.spawnTimer > 2.0) {
          gameState.spawnTimer = 0;
          if (entities.length >= 10) return;
          const pPos = playerBody.translation();
          const angle = Math.random() * Math.PI * 2;
          const dist = 15 + Math.random() * 25;
          const sx = pPos.x + Math.cos(angle) * dist;
          const sz = pPos.z + Math.sin(angle) * dist;
          const cx = Math.floor(sx / CHUNK_SIZE);
          const cz = Math.floor(sz / CHUNK_SIZE);

          const city = getCityInfoWrapper(
            Math.floor(sx / CHUNK_SIZE),
            Math.floor(sz / CHUNK_SIZE)
          );
          let tooCloseToCity = false;
          if (city.exists) {
            const d = Math.sqrt(
              (sx - city.worldX) ** 2 + (sz - city.worldZ) ** 2
            );
            if (d < city.radius + 100) tooCloseToCity = true;
          }

          if (chunks[`${cx},${cz}`]) {
            const h = getTerrainHeightWrapper(sx, sz).height;
            if (gameState.dimension === "NORMAL") {
              if (
                !tooCloseToCity &&
                entities.filter((e) => e instanceof Builder).length < 1 &&
                Math.random() < 0.5
              ) {
                entities.push(
                  new Builder(
                    sx,
                    h + 3,
                    sz,
                    scene,
                    physicsWorld,
                    BLOCKS,
                    getTerrainHeightWrapper,
                    setBlockWrapper,
                    getCityInfoWrapper,
                    CHUNK_SIZE,
                    DESPAWN_DISTANCE
                  )
                );
              }
            } else {
              // UPSIDE_DOWN: Zombies, Mutantes e Skeletons
              const rand = Math.random();
              if (rand < 0.1) {
                entities.push(
                  new MutantZombie(sx, h + 3, sz, scene, physicsWorld)
                );
              } else if (rand < 0.4) {
                // NOVO: 30% chance de Skeleton
                entities.push(
                  new Skeleton(sx, h + 3, sz, scene, physicsWorld, Entity)
                );
              } else {
                entities.push(new Zombie(sx, h + 3, sz, scene, physicsWorld));
              }
            }
          }
        }
      }

      // Troca de dimensão
      function switchDimension() {
        // Dispose seguro
        import("./lib/rendering.js").then((module) => {
          const { disposeChunk } = module;
          for (let key in chunks) {
            disposeChunk(chunks[key], scene, physicsWorld);
            delete chunks[key];
          }
        });

        entities.forEach((e) => e.remove());
        entities.length = 0;
        
        if (gameState.dimension === "NORMAL") {
          gameState.dimension = "UPSIDE_DOWN";
          // UI Feedback
          const el = document.getElementById("dimension-label");
          el.innerText = "MUNDO INVERTIDO";
          el.style.color = "#ff0000";
          el.style.opacity = 1;
          setTimeout(() => (el.style.opacity = 0), 3000);
        } else {
          gameState.dimension = "NORMAL";
          // UI Feedback
          const el = document.getElementById("dimension-label");
          el.innerText = "MUNDO SUPERIOR";
          el.style.color = "#87CEEB";
          el.style.opacity = 1;
          setTimeout(() => (el.style.opacity = 0), 3000);
        }
        
        interactionMode = "BLOCK";
        updateHotbar(interactionMode, selectedBlock, selectedBlueprintIndex, BLOCKS, BLOCK_PROPS, BLUEPRINTS, gameState, document.getElementById("hotbar"));
        
        // Reposicionar player com segurança
        const pos = playerBody.translation();
        // Reset simples para altura segura, generateInitialChunks vai corrigir se precisar
        playerBody.setTranslation({ x: pos.x, y: 100, z: pos.z }, true); 
        playerBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
        
        updateEnvironment(0, gameState, scene, ambientLight, particles);
        
        // RE-GERAR chunks imediatamente
        generateInitialChunks(scene, physicsWorld).then(() => {
           // Ajustar posição fina após geração
           const h = getTerrainHeightWrapper(pos.x, pos.z).height;
           playerBody.setTranslation({ x: pos.x, y: h + 3, z: pos.z }, true);
           Logger.info("Dimensão trocada e terreno recarregado");
        });
      }

      // Dano
      // NOVO: Sistema de Combate do Jogador
      function attackEnemy() {
        if (!playerBody) return false;
        
        const pos = playerBody.translation();
        const direction = new THREE.Vector3(0, 0, -1);
        direction.applyEuler(camera.rotation);
        
        let closestEnemy = null;
        let closestDist = 4.0; // Alcance de 4 blocos
        
        // Buscar inimigo mais próximo na direção da mira
        entities.forEach(ent => {
          if (ent instanceof Zombie || ent instanceof MutantZombie || ent instanceof Skeleton) {
            const ePos = ent.rigidBody.translation();
            const toEnemy = new THREE.Vector3(
              ePos.x - pos.x,
              ePos.y - pos.y,
              ePos.z - pos.z
            );
            const dist = toEnemy.length();
            
            // Verificar se está no alcance e na direção da mira
            if (dist < closestDist) {
              toEnemy.normalize();
              const angle = direction.angleTo(toEnemy);
              
              // Cone de 30 graus
              if (angle < Math.PI / 6) {
                closestEnemy = ent;
                closestDist = dist;
              }
            }
          }
        });
        
        // Aplicar dano ao inimigo mais próximo
        if (closestEnemy) {
          closestEnemy.health -= 25;
          
          // Verificar morte
          if (closestEnemy.health <= 0) {
            if (closestEnemy.onDeath) {
              closestEnemy.onDeath(entities, Loot);
            }
            closestEnemy.remove();
            const idx = entities.indexOf(closestEnemy);
            if (idx > -1) entities.splice(idx, 1);
          }
          
          return true;
        }
        
        return false;
      }

      function takeDamage(amount) {
        playerStats.health = Math.max(0, playerStats.health - amount);
        const overlay = document.getElementById("damage-overlay");
        overlay.style.opacity = 0.5;
        setTimeout(() => (overlay.style.opacity = 0), 100);
        updatePlayerUI(playerStats, gameState);
        if (playerStats.health <= 0) {
          if (gameState.dimension === "UPSIDE_DOWN") {
            gameState.dimension = "NORMAL";
            const hotbarEl = document.getElementById("hotbar");
            updateHotbar(
              interactionMode,
              selectedBlock,
              selectedBlueprintIndex,
              BLOCKS,
              BLOCK_PROPS,
              BLUEPRINTS,
              gameState,
              hotbarEl
            );
          }
          const h = getTerrainHeightWrapper(0, 0).height;
          playerBody.setTranslation({ x: 0, y: h + 5, z: 0 }, true);
          playerBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
          playerStats.health = 100;
          playerStats.oxygen = 100;
          playerStats.stamina = 100;
          entities.forEach((e) => e.remove());
          entities.length = 0;
          entities.push(
            new Builder(
              10,
              h + 2,
              10,
              scene,
              physicsWorld,
              BLOCKS,
              getTerrainHeightWrapper,
              setBlockWrapper,
              getCityInfoWrapper,
              CHUNK_SIZE,
              DESPAWN_DISTANCE
            )
          );
        }
      }

      // Player update
      function updatePlayer(dt) {
        if (!playerBody) return;
        const velocity = playerBody.linvel();
        const deltaY = velocity.y - playerStats.lastVelocityY;
        if (deltaY > 35 && playerStats.lastVelocityY < -25)
          takeDamage(Math.floor((deltaY - 35) / 2));
        playerStats.lastVelocityY = velocity.y;
        const pos = playerBody.translation();
        const eyeY = pos.y + 0.6;
        const headBlock = getBlockWrapper(pos.x, eyeY, pos.z);
        if (
          headBlock === BLOCKS.WATER ||
          headBlock === BLOCKS.CORRUPTED_WATER
        ) {
          playerStats.oxygen = Math.max(0, playerStats.oxygen - 20 * dt);
          if (playerStats.oxygen <= 0) takeDamage(10 * dt);
        } else playerStats.oxygen = Math.min(100, playerStats.oxygen + 30 * dt);
        if (!keys["ShiftLeft"] && !keys["Space"])
          playerStats.stamina = Math.min(100, playerStats.stamina + 10 * dt);
        updatePlayerUI(playerStats, gameState);
        if (controls.isLocked) {
          let speed = 8.0;
          if (keys["ShiftLeft"] && playerStats.stamina > 0) {
            speed = 13.0;
            playerStats.stamina = Math.max(0, playerStats.stamina - 15 * dt);
          }
          const direction = new THREE.Vector3();
          const frontVector = new THREE.Vector3(
            0,
            0,
            (keys["KeyS"] ? 1 : 0) - (keys["KeyW"] ? 1 : 0)
          );
          const sideVector = new THREE.Vector3(
            (keys["KeyD"] ? 1 : 0) - (keys["KeyA"] ? 1 : 0),
            0,
            0
          );
          direction
            .addVectors(frontVector, sideVector)
            .normalize()
            .multiplyScalar(speed);
          direction.applyEuler(camera.rotation);
          playerBody.setLinvel(
            { x: direction.x, y: velocity.y, z: direction.z },
            true
          );
          if (keys["Space"]) {
            const ray = new RAPIER.Ray(
              { x: pos.x, y: pos.y, z: pos.z },
              { x: 0, y: -1, z: 0 }
            );
            const hit = physicsWorld.castRay(
              ray,
              1.05,
              true,
              undefined,
              undefined,
              undefined,
              playerBody
            );
            if (hit && playerStats.stamina > 5) {
              playerBody.setLinvel(
                { x: velocity.x, y: 12.0, z: velocity.z },
                true
              );
              playerStats.stamina -= 5;
            }
          }
        } else playerBody.setLinvel({ x: 0, y: velocity.y, z: 0 }, true);
        const t = playerBody.translation();
        camera.position.set(t.x, t.y + 0.6, t.z);
        if (t.y < -30) {
           // Check de Vazio / Queda infinita
           if (t.y < -50) {
               Logger.warn("Jogador caiu no vazio! Resetando...");
               const h = getTerrainHeightWrapper(t.x, t.z).height;
               playerBody.setTranslation({x: t.x, y: h + 10, z: t.z}, true);
               playerBody.setLinvel({x: 0, y: 0, z: 0}, true);
               takeDamage(10);
           } else {
               switchDimension();
           }
        }
      }

      // Seleção e preview
      const raycaster = new THREE.Raycaster();
      raycaster.far = 20;
      const selectBox = new THREE.LineSegments(
        new THREE.EdgesGeometry(new THREE.BoxGeometry(1.01, 1.01, 1.01)),
        new THREE.LineBasicMaterial({ color: 0x000000 })
      );
      scene.add(selectBox);
      selectBox.visible = false;

      const previewGeo = new THREE.BoxGeometry(1, 1, 1);
      const previewMat = new THREE.MeshBasicMaterial({
        color: 0x00ff00,
        wireframe: true,
        transparent: true,
        opacity: 0.5,
      });
      const previewMesh = new THREE.Mesh(previewGeo, previewMat);
      scene.add(previewMesh);
      previewMesh.visible = false;

      let currentTarget = null;
      let blueprintTarget = null;

      function updateSelection() {
        if (!controls.isLocked) return;
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        const intersects = raycaster.intersectObjects(scene.children);
        const hit = intersects.find(
          (i) =>
            i.object !== selectBox &&
            i.object !== previewMesh &&
            i.object.geometry &&
            i.face
        );

        if (hit) {
          if (interactionMode === "BLOCK") {
            previewMesh.visible = false;
            if (hit.distance < 6) {
              const p = hit.point
                .clone()
                .add(hit.face.normal.clone().multiplyScalar(-0.01));
              const x = Math.floor(p.x),
                y = Math.floor(p.y),
                z = Math.floor(p.z);
              selectBox.position.set(x + 0.5, y + 0.5, z + 0.5);
              selectBox.visible = true;
              selectBox.scale.set(1, 1, 1);
              currentTarget = { x, y, z, normal: hit.face.normal };
              blueprintTarget = null;
            } else {
              selectBox.visible = false;
              currentTarget = null;
            }
          } else {
            selectBox.visible = false;
            const bp = BLUEPRINTS[selectedBlueprintIndex];

            const p = hit.point.clone();
            const x = Math.floor(p.x);
            const y = Math.floor(p.y);
            const z = Math.floor(p.z);

            const cx = x + bp.width / 2;
            const cy = y + bp.height / 2;
            const cz = z + bp.depth / 2;

            previewMesh.position.set(cx, cy, cz);
            previewMesh.scale.set(bp.width, bp.height, bp.depth);
            previewMesh.visible = true;

            const pPos = playerBody.translation();
            const dx = Math.abs(pPos.x - cx);
            const dz = Math.abs(pPos.z - cz);
            const safeX = bp.width / 2 + 0.8;
            const safeZ = bp.depth / 2 + 0.8;

            let valid = true;
            if (
              dx < safeX &&
              dz < safeZ &&
              Math.abs(pPos.y - cy) < bp.height / 2 + 2
            ) {
              valid = false;
              previewMesh.material.color.setHex(0xff0000);
            } else {
              previewMesh.material.color.setHex(0x00ff00);
            }

            blueprintTarget = valid ? { x, y, z } : null;
            currentTarget = null;
          }
        } else {
          selectBox.visible = false;
          previewMesh.visible = false;
          currentTarget = null;
          blueprintTarget = null;
        }
      }

      // Mouse events
      document.addEventListener("mousedown", (e) => {
        if (!controls.isLocked) return;

        if (interactionMode === "BLOCK") {
          // NOVO: Atacar inimigos se não houver bloco selecionado
          if (!currentTarget && e.button === 0) {
            attackEnemy();
            return;
          }
          
          if (!currentTarget) return;
          if (e.button === 0) {
            if (
              getBlockWrapper(
                currentTarget.x,
                currentTarget.y,
                currentTarget.z
              ) !== BLOCKS.AIR
            ) {
              setBlockWrapper(
                currentTarget.x,
                currentTarget.y,
                currentTarget.z,
                BLOCKS.AIR
              );
            }
          } else if (e.button === 2) {
            const nx = currentTarget.x + currentTarget.normal.x;
            const ny = currentTarget.y + currentTarget.normal.y;
            const nz = currentTarget.z + currentTarget.normal.z;
            const pPos = playerBody.translation();
            const collision =
              pPos.x - PLAYER_RADIUS <= nx + 1 &&
              pPos.x + PLAYER_RADIUS >= nx &&
              pPos.y - PLAYER_HALF_HEIGHT <= ny + 1 &&
              pPos.y + PLAYER_HALF_HEIGHT >= ny &&
              pPos.z - PLAYER_RADIUS <= nz + 1 &&
              pPos.z + PLAYER_RADIUS >= nz;
            if (!collision) setBlockWrapper(nx, ny, nz, selectedBlock);
          }
        } else {
          if (e.button === 0 && blueprintTarget) {
            const bp = BLUEPRINTS[selectedBlueprintIndex];
            const blocksToPlace = bp.build(
              blueprintTarget.x,
              blueprintTarget.y,
              blueprintTarget.z
            );

            blocksToPlace.forEach((b) => {
              setBlockWrapper(b.x, b.y, b.z, b.type);
            });

            const oldColor = previewMesh.material.color.getHex();
            previewMesh.material.color.setHex(0xffff00);
            setTimeout(() => previewMesh.material.color.setHex(oldColor), 200);
          }
        }
      });

      // Hotbar selection
      const hotbarEl = document.getElementById("hotbar");
      document.addEventListener("keydown", (e) => {
        const k = parseInt(e.key);
        if (interactionMode === "BLOCK") {
          const pBlocks =
            gameState.dimension === "NORMAL"
              ? [1, 2, 3, 7, 16, 17, 18, 10, 8]
              : [11, 12, 13, 11, 12, 13, 10, 14, 8];
          if (k >= 1 && k <= pBlocks.length) {
            selectedBlock = pBlocks[k - 1];
            updateHotbar(
              interactionMode,
              selectedBlock,
              selectedBlueprintIndex,
              BLOCKS,
              BLOCK_PROPS,
              BLUEPRINTS,
              gameState,
              hotbarEl
            );
          }
        } else {
          if (k >= 1 && k <= BLUEPRINTS.length) {
            selectedBlueprintIndex = k - 1;
            updateHotbar(
              interactionMode,
              selectedBlock,
              selectedBlueprintIndex,
              BLOCKS,
              BLOCK_PROPS,
              BLUEPRINTS,
              gameState,
              hotbarEl
            );
          }
        }
      });

      // Resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Loop principal
      async function animate() {
        requestAnimationFrame(animate);
        const dt = Math.min(clock.getDelta(), 0.1);
        if (physicsWorld) {
          physicsWorld.step();
          updateEnvironment(dt, gameState, scene, ambientLight);
          await updateWorld();
          updateSpawning(dt);
          const pPos = playerBody.translation();
          particleSystem.update(
            dt,
            pPos,
            gameState.dimension === "UPSIDE_DOWN"
          );
          for (let i = entities.length - 1; i >= 0; i--) {
            if (entities[i] && typeof entities[i].update === "function") {
              // NOVO: Loot (coleta automática)
              if (entities[i] instanceof Loot) {
                const collected = entities[i].update(dt, pPos, playerStats, updatePlayerUI);
                if (collected) {
                  entities.splice(i, 1);
                }
                continue;
              }
              
              // NOVO: Projectile (física e colisão)
              if (entities[i] instanceof Projectile) {
                const removed = entities[i].update(dt, pPos, takeDamage, getBlockWrapper, BLOCKS, BLOCK_PROPS);
                if (removed) {
                  entities.splice(i, 1);
                }
                continue;
              }
              
              // NOVO: Skeleton (IA e ataque)
              if (entities[i] instanceof Skeleton) {
                entities[i].update(dt, pPos, gameState, entities, Projectile);
              }
              // Zombie e MutantZombie
              else if (
                entities[i] instanceof Zombie ||
                entities[i] instanceof MutantZombie
              ) {
                entities[i].update(
                  dt,
                  pPos,
                  gameState,
                  physicsWorld,
                  takeDamage
                );
              } 
              // Builder
              else if (entities[i] instanceof Builder) {
                entities[i].update(dt, pPos, gameState, physicsWorld);
              } 
              // Outras entidades
              else {
                entities[i].update(dt, pPos);
              }
              
              // Despawn por distância (não aplicar a Loot e Projectile)
              if (!(entities[i] instanceof Loot) && !(entities[i] instanceof Projectile)) {
                const dx = entities[i].rigidBody.translation().x - pPos.x;
                const dz = entities[i].rigidBody.translation().z - pPos.z;
                if (
                  Math.sqrt(dx * dx + dz * dz) > DESPAWN_DISTANCE ||
                  entities[i].rigidBody.translation().y < -50
                ) {
                  entities[i].remove();
                  entities.splice(i, 1);
                }
              }
            }
          }
          updatePlayer(dt);
          updateSelection();
        }
        renderer.render(scene, camera);
      }

      init();
    </script>
  </body>
</html>
